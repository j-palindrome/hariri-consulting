import{r as K}from"./jsx-runtime-7ou52q_D.js";var M=class C{static add(t,e){if(typeof e=="number")for(let r=0,n=t.length;r<n;r++)t[r]+=e;else for(let r=0,n=t.length;r<n;r++)t[r]+=e[r]||0;return t}static subtract(t,e){if(typeof e=="number")for(let r=0,n=t.length;r<n;r++)t[r]-=e;else for(let r=0,n=t.length;r<n;r++)t[r]-=e[r]||0;return t}static multiply(t,e){if(typeof e=="number")for(let r=0,n=t.length;r<n;r++)t[r]*=e;else{if(t.length!=e.length)throw new Error(`Cannot do element-wise multiply since the array lengths don't match: ${t.toString()} multiply-with ${e.toString()}`);for(let r=0,n=t.length;r<n;r++)t[r]*=e[r]}return t}static divide(t,e){if(typeof e=="number"){if(e===0)throw new Error("Cannot divide by zero");for(let r=0,n=t.length;r<n;r++)t[r]/=e}else{if(t.length!=e.length)throw new Error(`Cannot do element-wise divide since the array lengths don't match. ${t.toString()} divide-by ${e.toString()}`);for(let r=0,n=t.length;r<n;r++)t[r]/=e[r]}return t}static dot(t,e){if(t.length!=e.length)throw new Error("Array lengths don't match");let r=0;for(let n=0,i=t.length;n<i;n++)r+=t[n]*e[n];return r}static cross2D(t,e){return t[0]*e[1]-t[1]*e[0]}static cross(t,e){return new u(t[1]*e[2]-t[2]*e[1],t[2]*e[0]-t[0]*e[2],t[0]*e[1]-t[1]*e[0])}static magnitude(t){return Math.sqrt(C.dot(t,t))}static unit(t,e=void 0){const r=e===void 0?C.magnitude(t):e;return r===0?u.make(t.length):C.divide(t,r)}static abs(t){return C.map(t,Math.abs)}static floor(t){return C.map(t,Math.floor)}static ceil(t){return C.map(t,Math.ceil)}static round(t){return C.map(t,Math.round)}static max(t){let e=Number.MIN_VALUE,r=0;for(let n=0,i=t.length;n<i;n++)e=Math.max(e,t[n]),e===t[n]&&(r=n);return{value:e,index:r}}static min(t){let e=Number.MAX_VALUE,r=0;for(let n=0,i=t.length;n<i;n++)e=Math.min(e,t[n]),e===t[n]&&(r=n);return{value:e,index:r}}static sum(t){let e=0;for(let r=0,n=t.length;r<n;r++)e+=t[r];return e}static map(t,e){for(let r=0,n=t.length;r<n;r++)t[r]=e(t[r],r,t);return t}},x=class ${constructor(){this.reset()}get value(){return this._33}get domMatrix(){return new DOMMatrix($.toDOMMatrix(this._33))}reset(){this._33=$.scale2DMatrix(1,1)}scale2D(t,e=[0,0]){const r=$.scaleAt2DMatrix(t[0]||1,t[1]||1,e);return this._33=$.multiply(this._33,r),this}rotate2D(t,e=[0,0]){const r=$.rotateAt2DMatrix(Math.cos(t),Math.sin(t),e);return this._33=$.multiply(this._33,r),this}translate2D(t){const e=$.translate2DMatrix(t[0]||0,t[1]||0);return this._33=$.multiply(this._33,e),this}shear2D(t,e=[0,0]){const r=$.shearAt2DMatrix(Math.tan(t[0]||0),Math.tan(t[1]||1),e);return this._33=$.multiply(this._33,r),this}static add(t,e){if(typeof e!="number"){if(t[0].length!=e[0].length)throw new Error("Cannot add matrix if rows' and columns' size don't match.");if(t.length!=e.length)throw new Error("Cannot add matrix if rows' and columns' size don't match.")}const r=new h,n=typeof e=="number";for(let i=0,s=t.length;i<s;i++)r.push(t[i].$add(n?e:e[i]));return r}static multiply(t,e,r=!1,n=!1){const i=new h;if(typeof e!="number")if(n){if(t.length!=e.length)throw new Error("Cannot multiply matrix element-wise because the matrices' sizes don't match.");for(let s=0,l=t.length;s<l;s++)i.push(t[s].$multiply(e[s]))}else{if(!r&&t[0].length!=e.length)throw new Error("Cannot multiply matrix if rows in matrix-a don't match columns in matrix-b.");if(r&&t[0].length!=e[0].length)throw new Error("Cannot multiply matrix if transposed and the columns in both matrices don't match.");r||(e=$.transpose(e));for(let s=0,l=t.length;s<l;s++){const a=u.make(e.length,0);for(let o=0,f=e.length;o<f;o++)a[o]=M.dot(t[s],e[o]);i.push(a)}}else for(let s=0,l=t.length;s<l;s++)i.push(t[s].$multiply(e));return i}static zipSlice(t,e,r=!1){const n=[];for(let i=0,s=t.length;i<s;i++){if(t[i].length-1<e&&r===!1)throw`Index ${e} is out of bounds`;n.push(t[i][e]||r)}return new u(n)}static zip(t,e=!1,r=!1){const n=new h,i=r?t.reduce((s,l)=>Math.max(s,l.length),0):t[0].length;for(let s=0;s<i;s++)n.push($.zipSlice(t,s,e));return n}static transpose(t,e=!1,r=!1){return $.zip(t,e,r)}static toDOMMatrix(t){return[t[0][0],t[0][1],t[1][0],t[1][1],t[2][0],t[2][1]]}static transform2D(t,e){const r=t[0]*e[0][0]+t[1]*e[1][0]+e[2][0],n=t[0]*e[0][1]+t[1]*e[1][1]+e[2][1];return new u(r,n)}static scale2DMatrix(t,e){return new h(new u(t,0,0),new u(0,e,0),new u(0,0,1))}static rotate2DMatrix(t,e){return new h(new u(t,e,0),new u(-e,t,0),new u(0,0,1))}static shear2DMatrix(t,e){return new h(new u(1,t,0),new u(e,1,0),new u(0,0,1))}static translate2DMatrix(t,e){return new h(new u(1,0,0),new u(0,1,0),new u(t,e,1))}static scaleAt2DMatrix(t,e,r){const n=$.scale2DMatrix(t,e);return n[2][0]=-r[0]*t+r[0],n[2][1]=-r[1]*e+r[1],n}static rotateAt2DMatrix(t,e,r){const n=$.rotate2DMatrix(t,e);return n[2][0]=r[0]*(1-t)+r[1]*e,n[2][1]=r[1]*(1-t)-r[0]*e,n}static shearAt2DMatrix(t,e,r){const n=$.shear2DMatrix(t,e);return n[2][0]=-r[1]*e,n[2][1]=-r[0]*t,n}static reflectAt2DMatrix(t,e){const r=S.intercept(t,e);if(r==null)return[new u([-1,0,0]),new u([0,1,0]),new u([t[0]+e[0],0,1])];{const n=r.yi,i=Math.atan(r.slope)*2,s=Math.cos(i),l=Math.sin(i);return[new u([s,l,0]),new u([l,-s,0]),new u([-n*l,n+n*s,1])]}}},E=(A,t="expected")=>c.warn("Group's length is less than "+t,A),Q=(A,t="")=>c.warn(`Index ${t} is out of bound in Group`,A),S=class z{static fromAngle(t,e,r){let n=new h(new u(t),new u(t));return n[1].toAngle(e,r,!0),n}static slope(t,e){return e[0]-t[0]===0?void 0:(e[1]-t[1])/(e[0]-t[0])}static intercept(t,e){if(e[0]-t[0]!==0){let r=(e[1]-t[1])/(e[0]-t[0]),n=t[1]-r*t[0];return{slope:r,yi:n,xi:r===0?void 0:-n/r}}}static sideOfPt2D(t,e){let r=c.iterToArray(t);return(r[1][0]-r[0][0])*(e[1]-r[0][1])-(e[0]-r[0][0])*(r[1][1]-r[0][1])}static collinear(t,e,r,n=.01){let i=new u(0,0,0).to(t).$subtract(e),s=new u(0,0,0).to(t).$subtract(r);return i.$cross(s).divide(1e3).equals(new u(0,0,0),n)}static magnitude(t){let e=c.iterToArray(t);return e.length>=2?e[1].$subtract(e[0]).magnitude():0}static magnitudeSq(t){let e=c.iterToArray(t);return e.length>=2?e[1].$subtract(e[0]).magnitudeSq():0}static perpendicularFromPt(t,e,r=!1){let n=c.iterToArray(t);if(n[0].equals(n[1]))return;let i=n[0].$subtract(n[1]),s=n[1].$subtract(e),l=s.$subtract(i.$project(s));return r?l:l.$add(e)}static distanceFromPt(t,e){let r=c.iterToArray(t),n=z.perpendicularFromPt(r,e,!0);return n?n.magnitude():r[0].$subtract(e).magnitude()}static intersectRay2D(t,e){let r=c.iterToArray(t),n=c.iterToArray(e),i=z.intercept(r[0],r[1]),s=z.intercept(n[0],n[1]),l=r[0],a=n[0];if(i==null){if(s==null)return;let o=-s.slope*(a[0]-l[0])+a[1];return new u(l[0],o)}else if(s==null){let o=-i.slope*(l[0]-a[0])+l[1];return new u(a[0],o)}else if(s.slope!=i.slope){let o=(i.slope*l[0]-s.slope*a[0]+a[1]-l[1])/(i.slope-s.slope),f=i.slope*(o-l[0])+l[1];return new u(o,f)}else return i.yi==s.yi?new u(l[0],l[1]):void 0}static intersectLine2D(t,e){let r=c.iterToArray(t),n=c.iterToArray(e),i=z.intersectRay2D(r,n);return i&&w.withinBound(i,r[0],r[1])&&w.withinBound(i,n[0],n[1])?i:void 0}static intersectLineWithRay2D(t,e){let r=c.iterToArray(t),n=c.iterToArray(e),i=z.intersectRay2D(r,n);return i&&w.withinBound(i,r[0],r[1])?i:void 0}static intersectPolygon2D(t,e,r=!1){let n=c.iterToArray(t),i=c.iterToArray(e),s=r?z.intersectLineWithRay2D:z.intersectLine2D,l=new h;for(let a=0,o=i.length;a<o;a++){let f=a===o-1?0:a+1,d=s([i[a],i[f]],n);d&&l.push(d)}return l.length>0?l:void 0}static intersectLines2D(t,e,r=!1){let n=new h,i=r?z.intersectLineWithRay2D:z.intersectLine2D;for(let s of t)for(let l of e){let a=i(s,l);a&&n.push(a)}return n}static intersectGridWithRay2D(t,e){let r=c.iterToArray(t),n=z.intercept(new u(r[0]).subtract(e),new u(r[1]).subtract(e)),i=new h;return n&&n.xi&&i.push(new u(e[0]+n.xi,e[1])),n&&n.yi&&i.push(new u(e[0],e[1]+n.yi)),i}static intersectGridWithLine2D(t,e){let r=c.iterToArray(t),n=z.intersectGridWithRay2D(r,e),i=new h;for(let s=0,l=n.length;s<l;s++)w.withinBound(n[s],r[0],r[1])&&i.push(n[s]);return i}static intersectRect2D(t,e){let r=c.iterToArray(t),n=c.iterToArray(e),i=w.boundingBox(h.fromPtArray(r));return L.hasIntersectRect2D(i,n)?z.intersectLines2D([r],L.sides(n)):new h}static subpoints(t,e){let r=c.iterToArray(t),n=new h;for(let i=1;i<=e;i++)n.push(w.interpolate(r[0],r[1],i/(e+1)));return n}static crop(t,e,r=0,n=!0){let i=c.iterToArray(t),l=i[r===0?1:0].$subtract(i[r]);if(l[0]===0||e[0]===0)return i[r];if(n){let a=l.unit().multiply(e[1]);return i[r].$add(a)}else{let a=L.fromCenter(i[r],e),o=L.sides(a),f=0;return Math.abs(l[1]/l[0])>Math.abs(e[1]/e[0])?f=l[1]<0?0:2:f=l[0]<0?3:1,z.intersectRay2D(o[f],i)}}static marker(t,e,r="arrow",n=!0){let i=c.iterToArray(t),s=n?0:1,l=n?1:0,a=i[s].$subtract(i[l]);if(a.magnitudeSq()===0)return new h;a.unit();let o=w.perpendicular(a).multiply(e[0]).add(i[l]);return r=="arrow"?(o.add(a.$multiply(e[1])),new h(i[l],o[0],o[1])):new h(o[0],o[1])}static toRect(t){let e=c.iterToArray(t);return new h(e[0].$min(e[1]),e[0].$max(e[1]))}},L=class R{static from(t,e,r){return R.fromTopLeft(t,e,r)}static fromTopLeft(t,e,r){let n=typeof e=="number"?[e,r||e]:e;return new h(new u(t),new u(t).add(n))}static fromCenter(t,e,r){let n=typeof e=="number"?[e/2,(r||e)/2]:new u(e).divide(2);return new h(new u(t).subtract(n),new u(t).add(n))}static toCircle(t,e=!0){return I.fromRect(t,e)}static toSquare(t,e=!1){let r=c.iterToArray(t),n=R.size(r),i=e?n.maxValue().value:n.minValue().value;return R.fromCenter(R.center(r),i,i)}static size(t){let e=c.iterToArray(t);return e[0].$max(e[1]).subtract(e[0].$min(e[1]))}static center(t){let e=c.iterToArray(t),r=e[0].$min(e[1]),n=e[0].$max(e[1]);return r.add(n.$subtract(r).divide(2))}static corners(t){let e=c.iterToArray(t),r=e[0].$min(e[1]),n=e[0].$max(e[1]);return new h(r,new u(n.x,r.y),n,new u(r.x,n.y))}static sides(t){let[e,r,n,i]=R.corners(t);return[new h(e,r),new h(r,n),new h(n,i),new h(i,e)]}static boundingBox(t){let e=c.iterToArray(t),r=c.flatten(e,!1),n=u.make(2,Number.MAX_VALUE),i=u.make(2,Number.MIN_VALUE);for(let s=0,l=r.length;s<l;s++){let a=0;for(let o of r[s])if(n[a]=Math.min(n[a],o[a]),i[a]=Math.max(i[a],o[a]),++a>=2)break}return new h(n,i)}static polygon(t){return R.corners(t)}static quadrants(t,e){let r=c.iterToArray(t),n=R.corners(r),i=e!=null?new u(e):R.center(r);return n.map(s=>new h(s,i).boundingBox())}static halves(t,e=.5,r=!1){let n=c.iterToArray(t),i=n[0].$min(n[1]),s=n[0].$max(n[1]),l=r?B.lerp(i[1],s[1],e):B.lerp(i[0],s[0],e);return r?[new h(i,new u(s[0],l)),new h(new u(i[0],l),s)]:[new h(i,new u(l,s[1])),new h(new u(l,i[1]),s)]}static withinBound(t,e){let r=c.iterToArray(t);return w.withinBound(e,r[0],r[1])}static hasIntersectRect2D(t,e,r=!1){let n=c.iterToArray(t),i=c.iterToArray(e);return r&&(n=w.boundingBox(n),i=w.boundingBox(i)),!(n[0][0]>i[1][0]||i[0][0]>n[1][0]||n[0][1]>i[1][1]||i[0][1]>n[1][1])}static intersectRect2D(t,e){let r=c.iterToArray(t),n=c.iterToArray(e);return R.hasIntersectRect2D(r,n)?S.intersectLines2D(R.sides(r),R.sides(n)):new h}},I=class Y{static fromRect(t,e=!1){let r=c.iterToArray(t),n=0,i=n=L.size(r).minValue().value/2;if(e){let s=L.size(r).maxValue().value/2;n=Math.sqrt(i*i+s*s)}else n=i;return new h(L.center(r),new u(n,n))}static fromTriangle(t,e=!1){return e?j.circumcircle(t):j.incircle(t)}static fromCenter(t,e){return new h(new u(t),new u(e,e))}static withinBound(t,e,r=0){let n=c.iterToArray(t),i=n[0].$subtract(e);return i.dot(i)+r<n[1].x*n[1].x}static intersectRay2D(t,e){let r=c.iterToArray(t),n=c.iterToArray(e),i=n[0].$subtract(n[1]),s=r[0].$subtract(n[0]),l=i.dot(i),a=s.dot(i),o=s.dot(s)-r[1].x*r[1].x,f=a/l,d=o/l,p=f*f-d;if(p<0)return new h;{let g=Math.sqrt(p),v=-f+g,T=n[0].$subtract(i.$multiply(v));if(p===0)return new h(T);let V=-f-g,U=n[0].$subtract(i.$multiply(V));return new h(T,U)}}static intersectLine2D(t,e){let r=c.iterToArray(t),n=c.iterToArray(e),i=Y.intersectRay2D(r,n),s=new h;if(i.length>0)for(let l=0,a=i.length;l<a;l++)L.withinBound(n,i[l])&&s.push(i[l]);return s}static intersectCircle2D(t,e){let r=c.iterToArray(t),n=c.iterToArray(e),i=n[0].$subtract(r[0]),s=i.magnitudeSq(),l=Math.sqrt(s),a=r[1].x,o=n[1].x,f=a*a,d=o*o;if(l>a+o)return new h;if(l<Math.abs(a-o))return new h(r[0].clone());{let p=(f-d+s)/(2*l),g=Math.sqrt(f-p*p),v=i.$multiply(p/l).add(r[0]);return new h(new u(v.x+g*i.y/l,v.y-g*i.x/l),new u(v.x-g*i.y/l,v.y+g*i.x/l))}}static intersectRect2D(t,e){let r=c.iterToArray(t),n=c.iterToArray(e),i=L.sides(n),s=[];for(let l=0,a=i.length;l<a;l++){let o=Y.intersectLine2D(r,i[l]);o.length>0&&s.push(o)}return c.flatten(s)}static toRect(t,e=!1){let r=c.iterToArray(t),n=r[1][0];if(e){let i=Math.sqrt(n*n)/2;return new h(r[0].$subtract(i),r[0].$add(i))}else return new h(r[0].$subtract(n),r[0].$add(n))}static toTriangle(t,e=!0){let r=c.iterToArray(t);if(e){let n=-Math.PI/2,i=Math.PI*2/3,s=new h;for(let l=0;l<3;l++)s.push(r[0].clone().toAngle(n,r[1][0],!0)),n+=i;return s}else return j.fromCenter(r[0],r[1][0])}},j=class k{static fromRect(t){let e=c.iterToArray(t),r=e[0].$add(e[1]).divide(2);r.y=e[0][1];let n=e[1].clone();return n.x=e[0][0],new h(r,e[1].clone(),n)}static fromCircle(t){return I.toTriangle(t,!0)}static fromCenter(t,e){return k.fromCircle(I.fromCenter(t,e))}static medial(t){let e=c.iterToArray(t);return e.length<3?E(new h,3):N.midpoints(e,!0)}static oppositeSide(t,e){let r=c.iterToArray(t);return r.length<3?E(new h,3):e===0?h.fromPtArray([r[1],r[2]]):e===1?h.fromPtArray([r[0],r[2]]):h.fromPtArray([r[0],r[1]])}static altitude(t,e){let r=c.iterToArray(t),n=k.oppositeSide(r,e);return n.length>1?new h(r[e],S.perpendicularFromPt(n,r[e])):new h}static orthocenter(t){let e=c.iterToArray(t);if(e.length<3)return E(void 0,3);let r=k.altitude(e,0),n=k.altitude(e,1);return S.intersectRay2D(r,n)}static incenter(t){let e=c.iterToArray(t);if(e.length<3)return E(void 0,3);let r=N.bisector(e,0).add(e[0]),n=N.bisector(e,1).add(e[1]);return S.intersectRay2D(new h(e[0],r),new h(e[1],n))}static incircle(t,e){let r=c.iterToArray(t),n=e||k.incenter(r),i=N.area(r),s=N.perimeter(r,!0),l=2*i/s.total;return I.fromCenter(n,l)}static circumcenter(t){let e=c.iterToArray(t),r=k.medial(e),n=[r[0],w.perpendicular(e[0].$subtract(r[0])).p1.$add(r[0])],i=[r[1],w.perpendicular(e[1].$subtract(r[1])).p1.$add(r[1])];return S.intersectRay2D(n,i)}static circumcircle(t,e){let r=c.iterToArray(t),n=e||k.circumcenter(r),i=r[0].$subtract(n).magnitude();return I.fromCenter(n,i)}},N=class D{static centroid(t){return w.centroid(t)}static rectangle(t,e,r){return L.corners(L.fromCenter(t,e,r))}static fromCenter(t,e,r){let n=new h;for(let i=0;i<r;i++){let s=Math.PI*2*i/r;n.push(new u(Math.cos(s)*e,Math.sin(s)*e).add(t))}return n}static lineAt(t,e){let r=c.iterToArray(t);if(e<0||e>=r.length)throw new Error("index out of the Polygon's range");return new h(r[e],e===r.length-1?r[0]:r[e+1])}static lines(t,e=!0){let r=c.iterToArray(t);if(r.length<2)return E(new h,2);let n=c.split(r,2,1);return e&&n.push(new h(r[r.length-1],r[0])),n.map(i=>i)}static midpoints(t,e=!1,r=.5){return D.lines(t,e).map(s=>w.interpolate(s[0],s[1],r))}static adjacentSides(t,e,r=!1){let n=c.iterToArray(t);if(n.length<2)return E(new h,2);if(e<0||e>=n.length)return Q(new h,e);let i=[],s=e-1;r&&s<0&&(s=n.length-1),s>=0&&i.push(new h(n[e],n[s]));let l=e+1;return r&&l>n.length-1&&(l=0),l<=n.length-1&&i.push(new h(n[e],n[l])),i}static bisector(t,e){let r=D.adjacentSides(t,e,!0);if(r.length>=2){let n=r[0][1].$subtract(r[0][0]).unit(),i=r[1][1].$subtract(r[1][0]).unit();return n.add(i).divide(2)}else return}static perimeter(t,e=!1){let r=D.lines(t,e),n=0,i=u.make(r.length,0);for(let s=0,l=r.length;s<l;s++){let a=S.magnitude(r[s]);n+=a,i[s]=a}return{total:n,segments:i}}static area(t){let e=c.iterToArray(t);if(e.length<3)return E(new h,3);let r=(i,s)=>i[0]*s[1]-i[1]*s[0],n=0;for(let i=0,s=e.length;i<s;i++)i<e.length-1?n+=r(e[i],e[i+1]):n+=r(e[i],e[0]);return Math.abs(n/2)}static convexHull(t,e=!1){let r=c.iterToArray(t);if(r.length<3)return E(new h,3);e||(r=r.slice(),r.sort((o,f)=>o[0]-f[0]));let n=(o,f,d)=>(f[0]-o[0])*(d[1]-o[1])-(d[0]-o[0])*(f[1]-o[1])>0,i=[],s=r.length-2,l=s+3;i[s]=r[2],i[l]=r[2],n(r[0],r[1],r[2])?(i[s+1]=r[0],i[s+2]=r[1]):(i[s+1]=r[1],i[s+2]=r[0]);for(let o=3,f=r.length;o<f;o++){let d=r[o];if(!(n(i[s],i[s+1],d)&&n(i[l-1],i[l],d))){for(;!n(i[s],i[s+1],d);)s+=1;for(s-=1,i[s]=d;!n(i[l-1],i[l],d);)l-=1;l+=1,i[l]=d}}let a=new h;for(let o=0;o<l-s;o++)a.push(i[s+o]);return a}static network(t,e=0){let r=c.iterToArray(t),n=[];for(let i=0,s=r.length;i<s;i++)i!=e&&n.push(new h(r[e],r[i]));return n}static nearestPt(t,e){let r=Number.MAX_VALUE,n=-1,i=0;for(let s of t){let l=s.$subtract(e).magnitudeSq();l<r&&(r=l,n=i),i++}return n}static projectAxis(t,e){let r=c.iterToArray(t),n=e.dot(r[0]),i=new u(n,n);for(let s=1,l=r.length;s<l;s++)n=e.dot(r[s]),i=new u(Math.min(n,i[0]),Math.max(n,i[1]));return i}static _axisOverlap(t,e,r){let n=D.projectAxis(t,r),i=D.projectAxis(e,r);return n[0]<i[0]?i[0]-n[1]:n[0]-i[1]}static hasIntersectPoint(t,e){let r=c.iterToArray(t),n=!1;for(let i=0,s=r.length;i<s;i++){let l=D.lineAt(r,i);l[0][1]>e[1]!=l[1][1]>e[1]&&e[0]<(l[1][0]-l[0][0])*(e[1]-l[0][1])/(l[1][1]-l[0][1])+l[0][0]&&(n=!n)}return n}static hasIntersectCircle(t,e){let r=c.iterToArray(t),n=c.iterToArray(e),i={which:-1,dist:0,normal:null,edge:null,vertex:null},s=n[0],l=n[1][0],a=Number.MAX_SAFE_INTEGER;for(let f=0,d=r.length;f<d;f++){let p=D.lineAt(r,f),g=new u(p[0].y-p[1].y,p[1].x-p[0].x).unit(),v=new h(s.$add(g.$multiply(l)),s.$subtract(g.$multiply(l))),T=D._axisOverlap(r,v,g);if(T>0)return null;Math.abs(T)<a&&(L.withinBound(p,S.perpendicularFromPt(p,s))||I.intersectLine2D(e,p).length>0)&&(i.edge=p,i.normal=g,a=Math.abs(T),i.which=f)}return i.edge?(s.$subtract(D.centroid(r)).dot(i.normal)<0&&i.normal.multiply(-1),i.dist=a,i.vertex=s,i):null}static hasIntersectPolygon(t,e){let r=c.iterToArray(t),n=c.iterToArray(e),i={which:-1,dist:0,normal:new u,edge:new h,vertex:new u},s=Number.MAX_SAFE_INTEGER;for(let g=0,v=r.length+n.length;g<v;g++){let T=g<r.length?D.lineAt(r,g):D.lineAt(n,g-r.length),V=new u(T[0].y-T[1].y,T[1].x-T[0].x).unit(),U=D._axisOverlap(r,n,V);if(U>0)return null;Math.abs(U)<s&&(i.edge=T,i.normal=V,s=Math.abs(U),i.which=g<r.length?0:1)}i.dist=s;let l=i.which===0?n:r,a=i.which===0?r:n,o=D.centroid(l),f=D.centroid(a);o.$subtract(f).dot(i.normal)<0&&i.normal.multiply(-1);let p=Number.MAX_SAFE_INTEGER;for(let g=0,v=l.length;g<v;g++){let T=i.normal.dot(l[g].$subtract(f));T<p&&(p=T,i.vertex=l[g])}return i}static intersectPolygon2D(t,e){let r=c.iterToArray(t),n=c.iterToArray(e),i=D.lines(r),s=[];for(let l=0,a=i.length;l<a;l++){let o=S.intersectPolygon2D(i[l],n,!1);o&&s.push(o)}return c.flatten(s,!0)}static toRects(t){let e=[];for(let n of t)e.push(w.boundingBox(n));let r=c.flatten(e,!1);return e.unshift(w.boundingBox(r)),e}},Z=class y{static getSteps(t){let e=new h;for(let r=0;r<=t;r++){let n=r/t;e.push(new u(n*n*n,n*n,n,1))}return e}static controlPoints(t,e=0,r=!1){let n=c.iterToArray(t);if(e>n.length-1)return new h;let i=l=>l<n.length-1?l:n.length-1,s=n[e];return e=r?e:e+1,new h(s,n[i(e++)],n[i(e++)],n[i(e++)])}static _calcPt(t,e){let r=t.reduce((i,s,l)=>i+s.x*e[l],0),n=t.reduce((i,s,l)=>i+s.y*e[l],0);if(t[0].length>2){let i=t.reduce((s,l,a)=>s+l.z*e[a],0);return new u(r,n,i)}return new u(r,n)}static catmullRom(t,e=10){let r=c.iterToArray(t);if(r.length<2)return new h;let n=new h,i=y.getSteps(e),s=y.controlPoints(r,0,!0);for(let a=0;a<=e;a++)n.push(y.catmullRomStep(i[a],s));let l=0;for(;l<r.length-2;){let a=y.controlPoints(r,l);if(a.length>0){for(let o=0;o<=e;o++)n.push(y.catmullRomStep(i[o],a));l++}}return n}static catmullRomStep(t,e){let r=new h(new u(-.5,1,-.5,0),new u(1.5,-2.5,0,1),new u(-1.5,2,.5,0),new u(.5,-.5,0,0));return y._calcPt(e,x.multiply([t],r,!0)[0])}static cardinal(t,e=10,r=.5){let n=c.iterToArray(t);if(n.length<2)return new h;let i=new h,s=y.getSteps(e),l=y.controlPoints(n,0,!0);for(let o=0;o<=e;o++)i.push(y.cardinalStep(s[o],l,r));let a=0;for(;a<n.length-2;){let o=y.controlPoints(n,a);if(o.length>0){for(let f=0;f<=e;f++)i.push(y.cardinalStep(s[f],o,r));a++}}return i}static cardinalStep(t,e,r=.5){let n=new h(new u(-1,2,-1,0),new u(-1,1,0,0),new u(1,-2,1,0),new u(1,-1,0,0)),i=x.multiply([t],n,!0)[0].multiply(r),s=2*t[0]-3*t[1]+1,l=-2*t[0]+3*t[1],a=y._calcPt(e,i);return a.x+=s*e[1].x+l*e[2].x,a.y+=s*e[1].y+l*e[2].y,a.length>2&&(a.z+=s*e[1].z+l*e[2].z),a}static bezier(t,e=10){let r=c.iterToArray(t);if(r.length<4)return new h;let n=new h,i=y.getSteps(e),s=0;for(;s<r.length-3;){let l=y.controlPoints(r,s);if(l.length>0){for(let a=0;a<=e;a++)n.push(y.bezierStep(i[a],l));s+=3}}return n}static bezierStep(t,e){let r=new h(new u(-1,3,-3,1),new u(3,-6,3,0),new u(-3,3,0,0),new u(1,0,0,0));return y._calcPt(e,x.multiply([t],r,!0)[0])}static bspline(t,e=10,r=1){let n=c.iterToArray(t);if(n.length<2)return new h;let i=new h,s=y.getSteps(e),l=0;for(;l<n.length-3;){let a=y.controlPoints(n,l);if(a.length>0){if(r!==1)for(let o=0;o<=e;o++)i.push(y.bsplineTensionStep(s[o],a,r));else for(let o=0;o<=e;o++)i.push(y.bsplineStep(s[o],a));l++}}return i}static bsplineStep(t,e){let r=new h(new u(-.16666666666666666,.5,-.5,.16666666666666666),new u(.5,-1,0,.6666666666666666),new u(-.5,.5,.5,.16666666666666666),new u(.16666666666666666,0,0,0));return y._calcPt(e,x.multiply([t],r,!0)[0])}static bsplineTensionStep(t,e,r=1){let n=new h(new u(-.16666666666666666,.5,-.5,.16666666666666666),new u(-1.5,2,0,-.3333333333333333),new u(1.5,-2.5,.5,.16666666666666666),new u(.16666666666666666,0,0,0)),i=x.multiply([t],n,!0)[0].multiply(r),s=2*t[0]-3*t[1]+1,l=-2*t[0]+3*t[1],a=y._calcPt(e,i);return a.x+=s*e[1].x+l*e[2].x,a.y+=s*e[1].y+l*e[2].y,a.length>2&&(a.z+=s*e[1].z+l*e[2].z),a}};function tt(){let A=4022871197;return function(e){if(e){e=e.toString();for(let r=0;r<e.length;r++){A+=e.charCodeAt(r);let n=.02519603282416938*A;A=n>>>0,n-=A,n*=A,A=n>>>0,n-=A,A+=n*4294967296}return(A>>>0)*23283064365386963e-26}else A=4022871197}}function et(A){let t=48,e=1,r=t,n=new Array(t),i,s,l=0,a=tt();for(i=0;i<t;i++)n[i]=a(Math.random().toString());function o(){for(a(),i=0;i<t;i++)n[i]=a(" ");e=1,r=t}function f(p){return p=p.replace(/(^\s*)|(\s*$)/gi,""),p=p.replace(/[\x00-\x1F]/gi,""),p=p.replace(/\n /,`
`),p}function d(p){for(p=f(p),a(p),i=0;i<p.length;i++)for(l=p.charCodeAt(i),s=0;s<t;s++)n[s]-=a(l.toString()),n[s]<0&&(n[s]+=1)}return o(),d(A),{random(){++r>=t&&(r=0);let p=1768863*n[r]+e*23283064365386963e-26;return n[r]=p-(e=p|0)}}}var B=class F{static equals(t,e,r=1e-5){return Math.abs(t-e)<r}static lerp(t,e,r){return(1-r)*t+r*e}static clamp(t,e,r){return Math.max(e,Math.min(r,t))}static boundValue(t,e,r){const n=Math.abs(r-e);let i=t%n;return i>r?i-=n:i<e&&(i+=n),i}static within(t,e,r){return t>=Math.min(e,r)&&t<=Math.max(e,r)}static randomRange(t,e=0){const r=t>e?t-e:e-t;return t+F.random()*r}static randomPt(t,e){const r=new u(t.length),n=e?M.subtract(e.slice(),t):t,i=e?t:new u(t.length).fill(0);for(let s=0,l=r.length;s<l;s++)r[s]=F.random()*n[s]+i[s];return r}static normalizeValue(t,e,r){const n=Math.min(e,r),i=Math.max(e,r);return(t-n)/(i-n)}static sum(t){const e=c.iterToArray(t),r=new u(e[0]);for(let n=1,i=e.length;n<i;n++)M.add(r,e[n]);return r}static average(t){const e=c.iterToArray(t);return F.sum(e).divide(e.length)}static cycle(t,e=rt.sineInOut){return e(t>.5?2-t*2:t*2)}static mapToRange(t,e,r,n,i){if(e==r)throw new Error("[currMin, currMax] must define a range that is not zero");const s=Math.min(n,i),l=Math.max(n,i);return F.normalizeValue(t,e,r)*(l-s)+s}static seed(t){this.generator=et(t)}static random(){return this.generator?this.generator.random():Math.random()}},w=class _{static boundAngle(t){return B.boundValue(t,0,360)}static boundRadian(t){return B.boundValue(t,0,b.two_pi)}static toRadian(t){return t*b.deg_to_rad}static toDegree(t){return t*b.rad_to_deg}static boundingBox(t){let e,r;for(const n of t)e==null?(e=n.clone(),r=n.clone()):(e=e.$min(n),r=r.$max(n));return new h(e,r)}static centroid(t){return B.average(t)}static anchor(t,e=0,r="to"){const n=r=="to"?"subtract":"add";let i=0;for(const s of t)typeof e=="number"?e!==i&&s[n](t[e]):s[n](e),i++}static interpolate(t,e,r=.5){const n=Math.min(t.length,e.length),i=u.make(n);for(let s=0;s<n;s++)i[s]=t[s]*(1-r)+e[s]*r;return i}static perpendicular(t,e=b.xy){const r=e[1],n=e[0],i=new u(t),s=new u(i);s[n]=-i[r],s[r]=i[n];const l=new u(i);return l[n]=i[r],l[r]=-i[n],new h(s,l)}static isPerpendicular(t,e){return new u(t).dot(e)===0}static withinBound(t,e,r){for(let n=0,i=Math.min(t.length,e.length,r.length);n<i;n++)if(!B.within(t[n],e[n],r[n]))return!1;return!0}static sortEdges(t){const e=c.iterToArray(t),r=_.boundingBox(e),n=r[1].add(r[0]).divide(2),i=(s,l)=>{if(s.length<2||l.length<2)throw new Error("Pt dimension cannot be less than 2");const a=s.$subtract(n),o=l.$subtract(n);if(a[0]>=0&&o[0]<0)return 1;if(a[0]<0&&o[0]>=0)return-1;if(a[0]==0&&o[0]==0)return a[1]>=0||o[1]>=0?a[1]>o[1]?1:-1:o[1]>a[1]?1:-1;const f=a.$cross2D(o);return f<0?1:f>0?-1:a[0]*a[0]+a[1]*a[1]>o[0]*o[0]+o[1]*o[1]?1:-1};return e.sort(i)}static scale(t,e,r){const n=c.iterToArray(t[0]!==void 0&&typeof t[0]=="number"?[t]:t),i=typeof e=="number"?u.make(n[0].length,e):e;r||(r=u.make(n[0].length,0));for(let s=0,l=n.length;s<l;s++){const a=n[s];for(let o=0,f=a.length;o<f;o++)a[o]=r&&r[o]?r[o]+(a[o]-r[o])*i[o]:a[o]*i[o]}return _}static rotate2D(t,e,r,n){const i=c.iterToArray(t[0]!==void 0&&typeof t[0]=="number"?[t]:t),s=r?x.rotateAt2DMatrix:x.rotate2DMatrix;r||(r=u.make(i[0].length,0));const l=Math.cos(e),a=Math.sin(e);for(let o=0,f=i.length;o<f;o++){const d=n?i[o].$take(n):i[o];if(d.to(x.transform2D(d,s(l,a,r))),n)for(let p=0;p<n.length;p++)i[o][n[p]]=d[p]}return _}static shear2D(t,e,r,n){const i=c.iterToArray(t[0]!==void 0&&typeof t[0]=="number"?[t]:t),s=typeof e=="number"?[e,e]:e;r||(r=u.make(i[0].length,0));const l=r?x.shearAt2DMatrix:x.shear2DMatrix,a=Math.tan(s[0]),o=Math.tan(s[1]);for(let f=0,d=i.length;f<d;f++){const p=n?i[f].$take(n):i[f];if(p.to(x.transform2D(p,l(a,o,r))),n)for(let g=0;g<n.length;g++)i[f][n[g]]=p[g]}return _}static reflect2D(t,e,r){const n=c.iterToArray(t[0]!==void 0&&typeof t[0]=="number"?[t]:t),i=c.iterToArray(e),s=x.reflectAt2DMatrix(i[0],i[1]);for(let l=0,a=n.length;l<a;l++){const o=r?n[l].$take(r):n[l];if(o.to(x.transform2D(o,s)),r)for(let f=0;f<r.length;f++)n[l][r[f]]=o[f]}return _}static cosTable(){const t=new Float64Array(360);for(let r=0;r<360;r++)t[r]=Math.cos(r*Math.PI/180);return{table:t,cos:r=>t[Math.floor(_.boundAngle(_.toDegree(r)))]}}static sinTable(){const t=new Float64Array(360);for(let r=0;r<360;r++)t[r]=Math.sin(r*Math.PI/180);return{table:t,sin:r=>t[Math.floor(_.boundAngle(_.toDegree(r)))]}}},rt=class X{static linear(t,e=1){return e*t}static quadraticIn(t,e=1){return e*t*t}static quadraticOut(t,e=1){return-e*t*(t-2)}static quadraticInOut(t,e=1){const r=t*2;return t<.5?e/2*t*t*4:-e/2*((r-1)*(r-3)-1)}static cubicIn(t,e=1){return e*t*t*t}static cubicOut(t,e=1){const r=t-1;return e*(r*r*r+1)}static cubicInOut(t,e=1){const r=t*2;return t<.5?e/2*r*r*r:e/2*((r-2)*(r-2)*(r-2)+2)}static exponentialIn(t,e=1,r=.25){return e*Math.pow(t,1/r)}static exponentialOut(t,e=1,r=.25){return e*Math.pow(t,r)}static sineIn(t,e=1){return-e*Math.cos(t*b.half_pi)+e}static sineOut(t,e=1){return e*Math.sin(t*b.half_pi)}static sineInOut(t,e=1){return-e/2*(Math.cos(Math.PI*t)-1)}static cosineApprox(t,e=1){const r=t*t,n=r*r,i=n*r;return e*(4*i/9-17*n/9+22*r/9)}static circularIn(t,e=1){return-e*(Math.sqrt(1-t*t)-1)}static circularOut(t,e=1){const r=t-1;return e*Math.sqrt(1-r*r)}static circularInOut(t,e=1){const r=t*2;return t<.5?-e/2*(Math.sqrt(1-r*r)-1):e/2*(Math.sqrt(1-(r-2)*(r-2))+1)}static elasticIn(t,e=1,r=.7){const n=t-1,i=r/b.two_pi*1.5707963267948966;return e*(-Math.pow(2,10*n)*Math.sin((n-i)*b.two_pi/r))}static elasticOut(t,e=1,r=.7){const n=r/b.two_pi*1.5707963267948966;return e*(Math.pow(2,-10*t)*Math.sin((t-n)*b.two_pi/r))+e}static elasticInOut(t,e=1,r=.6){let n=t*2;const i=r/b.two_pi*1.5707963267948966;return t<.5?(n-=1,e*(-.5*(Math.pow(2,10*n)*Math.sin((n-i)*b.two_pi/r)))):(n-=1,e*(.5*(Math.pow(2,-10*n)*Math.sin((n-i)*b.two_pi/r)))+e)}static bounceIn(t,e=1){return e-X.bounceOut(1-t,e)}static bounceOut(t,e=1){return t<1/2.75?e*(7.5625*t*t):t<2/2.75?(t-=1.5/2.75,e*(7.5625*t*t+.75)):t<2.5/2.75?(t-=2.25/2.75,e*(7.5625*t*t+.9375)):(t-=2.625/2.75,e*(7.5625*t*t+.984375))}static bounceInOut(t,e=1){return t<.5?X.bounceIn(t*2,e)/2:X.bounceOut(t*2-1,e)/2+e/2}static sigmoid(t,e=1,r=10){const n=r*(t-.5);return e/(1+Math.exp(-n))}static logSigmoid(t,e=1,r=.7){r=Math.max(b.epsilon,Math.min(1-b.epsilon,r)),r=1/(1-r);const n=1/(1+Math.exp((t-.5)*r*-2)),i=1/(1+Math.exp(r)),s=1/(1+Math.exp(-r));return e*(n-i)/(s-i)}static seat(t,e=1,r=.5){return t<.5?e*Math.pow(2*t,1-r)/2:e*(1-Math.pow(2*(1-t),1-r)/2)}static quadraticBezier(t,e=1,r=[.05,.95]){const n=typeof r!="number"?r[0]:r,i=typeof r!="number"?r[1]:.5;let s=1-2*n;s===0&&(s=b.epsilon);const l=(Math.sqrt(n*n+s*t)-n)/s;return e*((1-2*i)*(l*l)+2*i*l)}static cubicBezier(t,e=1,r=[.1,.7],n=[.9,.2]){const i=new h(new u(0,0),new u(r),new u(n),new u(1,1));return e*Z.bezierStep(new u(t*t*t,t*t,t,1),Z.controlPoints(i)).y}static quadraticTarget(t,e=1,r=[.2,.35]){const n=Math.min(1-b.epsilon,Math.max(b.epsilon,r[0])),i=Math.min(1,Math.max(0,r[1])),s=(1-i)/(1-n)-i/n,l=(s*(n*n)-i)/n,a=s*(t*t)-l*t;return e*Math.min(1,Math.max(0,a))}static cliff(t,e=1,r=.5){return t>r?e:0}static step(t,e,r,n,...i){const s=1/e,l=Math.floor(r/s)*s;return t(l,n,...i)}},b={xy:"xy",yz:"yz",xz:"xz",xyz:"xyz",horizontal:0,vertical:1,identical:0,right:4,bottom_right:5,bottom:6,bottom_left:7,left:8,top_left:1,top:2,top_right:3,epsilon:1e-4,max:Number.MAX_VALUE,min:Number.MIN_VALUE,pi:Math.PI,two_pi:6.283185307179586,half_pi:1.5707963267948966,quarter_pi:.7853981633974483,one_degree:.017453292519943295,rad_to_deg:57.29577951308232,deg_to_rad:.017453292519943295,gravity:9.81,newton:.10197,gaussian:.3989422804014327},H=class q{static warnLevel(t){return t&&(q._warnLevel=t),q._warnLevel}static getArgs(t){if(t.length<1)return[];let e=[],r=Array.isArray(t[0])||ArrayBuffer.isView(t[0]);if(typeof t[0]=="number")e=Array.prototype.slice.call(t);else if(typeof t[0]=="object"&&!r){let n=["x","y","z","w"],i=t[0];for(let s=0;s<n.length&&!(i.length&&s>=i.length||!(n[s]in i));s++)e.push(i[n[s]])}else r&&(e=[].slice.call(t[0]));return e}static warn(t="error",e=void 0){if(q.warnLevel()=="error")throw new Error(t);return q.warnLevel()=="warn"&&console.warn(t),e}static randomInt(t,e=0){return q.warn("Util.randomInt is deprecated. Please use `Num.randomRange`"),Math.floor(B.random()*t)+e}static split(t,e,r,n=!1,i=!0){let s=[],l=[],a=r||e,o=0;if(t.length<=0||a<=0)return[];for(;o<t.length;){l=[];for(let f=0;f<e;f++)if(n)l.push(t[(o+f)%t.length]);else{if(o+f>=t.length)break;l.push(t[o+f])}o+=a,(!i||i&&l.length===e)&&s.push(l)}return s}static flatten(t,e=!0){let r=e?new h:[];return r.concat.apply(r,t)}static combine(t,e,r){let n=[];for(let i=0,s=t.length;i<s;i++)for(let l=0,a=e.length;l<a;l++)n.push(r(t[i],e[l]));return n}static zip(t){let e=[];for(let r=0,n=t[0].length;r<n;r++){let i=[];for(let s=0;s<t.length;s++)i.push(t[s][r]);e.push(i)}return e}static stepper(t,e=0,r=1,n){let i=e;return function(){return i+=r,i>=t&&(i=e+(i-t)),n&&n(i),i}}static forRange(t,e,r=0,n=1){let i=[];for(let s=r,l=e;s<l;s+=n)i[s]=t(s);return i}static load(t,e){let r=new XMLHttpRequest;r.open("GET",t,!0),r.onload=function(){r.status>=200&&r.status<400?e(r.responseText,!0):e(`Server error (${r.status}) when loading "${t}"`,!1)},r.onerror=function(){e("Unknown network error",!1)},r.send()}static download(t,e="pts_canvas_image",r="png",n=1){const i=r==="jpg"?"jpeg":r;t.element.toBlob(function(s){const l=document.createElement("a"),a=URL.createObjectURL(s);l.href=a,l.download=`${e}.${r}`,document.body.appendChild(l),l.click(),document.body.removeChild(l),URL.revokeObjectURL(a)},`image/${i}`,n)}static performance(t=10){let e=Date.now(),r=[];return function(){const n=Date.now();return r.push(n-e),r.length>=t&&r.shift(),e=n,Math.floor(r.reduce((i,s)=>i+s,0)/r.length)}}static arrayCheck(t,e=2){return Array.isArray(t)&&t.length<e?(q.warn(`Requires ${e} or more Pts in this Group.`),!1):!0}static iterToArray(t){return Array.isArray(t)?t:[...t]}static isMobile(){return/iPhone|iPad|Android/i.test(navigator.userAgent)}};H._warnLevel="mute";var c=H,u=class P extends Float32Array{constructor(...t){let e;t.length===1&&typeof t[0]=="number"?e=t[0]:e=t.length>0?c.getArgs(t):[0,0],super(e)}static make(t,e=0,r=!1){const n=new Float32Array(t);if(e&&n.fill(e),r)for(let i=0,s=n.length;i<s;i++)n[i]=n[i]*B.random();return new P(n)}get id(){return this._id}set id(t){this._id=t}get x(){return this[0]}set x(t){this[0]=t}get y(){return this[1]}set y(t){this[1]=t}get z(){return this[2]}set z(t){this[2]=t}get w(){return this[3]}set w(t){this[3]=t}clone(){return new P(this)}equals(t,e=1e-6){for(let r=0,n=this.length;r<n;r++)if(Math.abs(this[r]-t[r])>e)return!1;return!0}to(...t){const e=c.getArgs(t);for(let r=0,n=Math.min(this.length,e.length);r<n;r++)this[r]=e[r];return this}$to(...t){return this.clone().to(...t)}toAngle(t,e,r=!1){const n=e??this.magnitude(),i=[Math.cos(t)*n,Math.sin(t)*n];return r?this.add(i):this.to(i)}op(t){const e=this;return(...r)=>t(e,...r)}ops(t){const e=[];for(let r=0,n=t.length;r<n;r++)e.push(this.op(t[r]));return e}$take(t){const e=[];for(let r=0,n=t.length;r<n;r++)e.push(this[t[r]]||0);return new P(e)}$concat(...t){return new P(this.toArray().concat(c.getArgs(t)))}add(...t){return t.length===1&&typeof t[0]=="number"?M.add(this,t[0]):M.add(this,c.getArgs(t)),this}$add(...t){return this.clone().add(...t)}subtract(...t){return t.length===1&&typeof t[0]=="number"?M.subtract(this,t[0]):M.subtract(this,c.getArgs(t)),this}$subtract(...t){return this.clone().subtract(...t)}multiply(...t){return t.length===1&&typeof t[0]=="number"?M.multiply(this,t[0]):M.multiply(this,c.getArgs(t)),this}$multiply(...t){return this.clone().multiply(...t)}divide(...t){return t.length===1&&typeof t[0]=="number"?M.divide(this,t[0]):M.divide(this,c.getArgs(t)),this}$divide(...t){return this.clone().divide(...t)}magnitudeSq(){return M.dot(this,this)}magnitude(){return M.magnitude(this)}unit(t=void 0){return M.unit(this,t),this}$unit(t=void 0){return this.clone().unit(t)}dot(...t){return M.dot(this,c.getArgs(t))}$cross2D(...t){return M.cross2D(this,c.getArgs(t))}$cross(...t){return M.cross(this,c.getArgs(t))}$project(...t){return this.$multiply(this.dot(...t)/this.magnitudeSq())}projectScalar(...t){return this.dot(...t)/this.magnitude()}abs(){return M.abs(this),this}$abs(){return this.clone().abs()}floor(){return M.floor(this),this}$floor(){return this.clone().floor()}ceil(){return M.ceil(this),this}$ceil(){return this.clone().ceil()}round(){return M.round(this),this}$round(){return this.clone().round()}minValue(){return M.min(this)}maxValue(){return M.max(this)}$min(...t){const e=c.getArgs(t),r=this.clone();for(let n=0,i=Math.min(this.length,e.length);n<i;n++)r[n]=Math.min(this[n],e[n]);return r}$max(...t){const e=c.getArgs(t),r=this.clone();for(let n=0,i=Math.min(this.length,e.length);n<i;n++)r[n]=Math.max(this[n],e[n]);return r}angle(t=b.xy){return Math.atan2(this[t[1]],this[t[0]])}angleBetween(t,e=b.xy){return w.boundRadian(this.angle(e))-w.boundRadian(t.angle(e))}scale(t,e){return w.scale(this,t,e||P.make(this.length,0)),this}rotate2D(t,e,r){return w.rotate2D(this,t,e||P.make(this.length,0),r),this}shear2D(t,e,r){return w.shear2D(this,t,e||P.make(this.length,0),r),this}reflect2D(t,e){return w.reflect2D(this,t,e),this}toString(){return`Pt(${this.join(", ")})`}toArray(){return[].slice.call(this)}toGroup(){return new h(P.make(this.length),this.clone())}toBound(){return new W(P.make(this.length),this.clone())}},h=class G extends Array{constructor(...t){super(...t)}get id(){return this._id}set id(t){this._id=t}get p1(){return this[0]}get p2(){return this[1]}get p3(){return this[2]}get p4(){return this[3]}get q1(){return this[this.length-1]}get q2(){return this[this.length-2]}get q3(){return this[this.length-3]}get q4(){return this[this.length-4]}clone(){const t=new G;for(let e=0,r=this.length;e<r;e++)t.push(this[e].clone());return t}static fromArray(t){const e=new G;for(const r of t){const n=r instanceof u?r:new u(r);e.push(n)}return e}static fromPtArray(t){return G.from(t)}split(t,e,r=!1){return c.split(this,t,e,r)}insert(t,e=0){return G.prototype.splice.apply(this,[e,0,...t]),this}remove(t=0,e=1){const r=t<0?[t*-1-1,e]:[t,e];return G.prototype.splice.apply(this,r)}segments(t=2,e=1,r=!1){return this.split(t,e,r)}lines(){return this.segments(2,1)}centroid(){return w.centroid(this)}boundingBox(){return w.boundingBox(this)}anchorTo(t=0){w.anchor(this,t,"to")}anchorFrom(t=0){w.anchor(this,t,"from")}op(t){const e=this;return(...r)=>t(e,...r)}ops(t){const e=[];for(let r=0,n=t.length;r<n;r++)e.push(this.op(t[r]));return e}interpolate(t){t=B.clamp(t,0,1);const e=this.length-1,r=1/(this.length-1),n=Math.floor(t/r);return w.interpolate(this[n],this[Math.min(this.length-1,n+1)],(t-n*r)*e)}moveBy(...t){return this.add(...t)}moveTo(...t){const e=new u(c.getArgs(t)).subtract(this[0]);return this.moveBy(e),this}scale(t,e){for(let r=0,n=this.length;r<n;r++)w.scale(this[r],t,e||this[0]);return this}rotate2D(t,e,r){for(let n=0,i=this.length;n<i;n++)w.rotate2D(this[n],t,e||this[0],r);return this}shear2D(t,e,r){for(let n=0,i=this.length;n<i;n++)w.shear2D(this[n],t,e||this[0],r);return this}reflect2D(t,e){for(let r=0,n=this.length;r<n;r++)w.reflect2D(this[r],t,e);return this}sortByDimension(t,e=!1){return this.sort((r,n)=>e?n[t]-r[t]:r[t]-n[t])}forEachPt(t,...e){if(!this[0][t])return c.warn(`${t} is not a function of Pt`),this;for(let r=0,n=this.length;r<n;r++)this[r]=this[r][t](...e);return this}add(...t){return this.forEachPt("add",...t)}subtract(...t){return this.forEachPt("subtract",...t)}multiply(...t){return this.forEachPt("multiply",...t)}divide(...t){return this.forEachPt("divide",...t)}$matrixAdd(t){return x.add(this,t)}$matrixMultiply(t,e=!1,r=!1){return x.multiply(this,t,e,r)}zipSlice(t,e=!1){return x.zipSlice(this,t,e)}$zip(t=void 0,e=!1){return x.zip(this,t,e)}toBound(){return W.fromGroup(this)}toString(){return"Group[ "+this.reduce((t,e)=>t+e.toString()+" ","")+" ]"}},W=class O extends h{constructor(...t){super(...t),this._center=new u,this._size=new u,this._topLeft=new u,this._bottomRight=new u,this._inited=!1,this.init()}static fromBoundingRect(t){const e=new O(new u(t.left||0,t.top||0),new u(t.right||0,t.bottom||0));return t.width&&t.height&&(e.size=new u(t.width,t.height)),e}static fromGroup(t){const e=c.iterToArray(t);if(e.length<2)throw new Error("Cannot create a Bound from a group that has less than 2 Pt");return new O(e[0],e[e.length-1])}init(){if(this.p1&&(this._size=this.p1.clone(),this._inited=!0),this.p1&&this.p2){const t=this.p1,e=this.p2;this.topLeft=t.$min(e),this._bottomRight=t.$max(e),this._updateSize(),this._inited=!0}}clone(){return new O(this._topLeft.clone(),this._bottomRight.clone())}_updateSize(){this._size=this._bottomRight.$subtract(this._topLeft).abs(),this._updateCenter()}_updateCenter(){this._center=this._size.$multiply(.5).add(this._topLeft)}_updatePosFromTop(){this._bottomRight=this._topLeft.$add(this._size),this._updateCenter()}_updatePosFromBottom(){this._topLeft=this._bottomRight.$subtract(this._size),this._updateCenter()}_updatePosFromCenter(){const t=this._size.$multiply(.5);this._topLeft=this._center.$subtract(t),this._bottomRight=this._center.$add(t)}get size(){return new u(this._size)}set size(t){this._size=new u(t),this._updatePosFromTop()}get center(){return new u(this._center)}set center(t){this._center=new u(t),this._updatePosFromCenter()}get topLeft(){return new u(this._topLeft)}set topLeft(t){this._topLeft=new u(t),this[0]=this._topLeft,this._updateSize()}get bottomRight(){return new u(this._bottomRight)}set bottomRight(t){this._bottomRight=new u(t),this[1]=this._bottomRight,this._updateSize()}get width(){return this._size.length>0?this._size.x:0}set width(t){this._size.x=t,this._updatePosFromTop()}get height(){return this._size.length>1?this._size.y:0}set height(t){this._size.y=t,this._updatePosFromTop()}get depth(){return this._size.length>2?this._size.z:0}set depth(t){this._size.z=t,this._updatePosFromTop()}get x(){return this.topLeft.x}get y(){return this.topLeft.y}get z(){return this.topLeft.z}get inited(){return this._inited}update(){return this._topLeft=this[0],this._bottomRight=this[1],this._updateSize(),this}},J=class m extends u{constructor(...t){super(...t),this._mode="rgb",this._isNorm=!1}static from(...t){const e=[1,1,1,1],r=c.getArgs(t);for(let n=0,i=e.length;n<i;n++)n<r.length&&(e[n]=r[n]);return new m(e)}static fromHex(t){if(t[0]=="#"&&(t=t.substr(1)),t.length<=3){const n=i=>t[i]||"F";t=`${n(0)}${n(0)}${n(1)}${n(1)}${n(2)}${n(2)}`}let e=1;t.length===8&&(e=t.substr(6)&&255/255,t=t.substring(0,6));const r=parseInt(t,16);return new m(r>>16,r>>8&255,r&255,e)}static rgb(...t){return m.from(...t).toMode("rgb")}static hsl(...t){return m.from(...t).toMode("hsl")}static hsb(...t){return m.from(...t).toMode("hsb")}static lab(...t){return m.from(...t).toMode("lab")}static lch(...t){return m.from(...t).toMode("lch")}static luv(...t){return m.from(...t).toMode("luv")}static xyz(...t){return m.from(...t).toMode("xyz")}static maxValues(t){return m.ranges[t].zipSlice(1).$take([0,1,2])}get hex(){return this.toString("hex")}get rgb(){return this.toString("rgb")}get rgba(){return this.toString("rgba")}clone(){const t=new m(this);return t.toMode(this._mode),t}toMode(t,e=!1){if(e){const r=this._mode.toUpperCase()+"to"+t.toUpperCase();if(m[r])this.to(m[r](this,this._isNorm,this._isNorm));else throw new Error("Cannot convert color with "+r)}return this._mode=t,this}get mode(){return this._mode}get r(){return this[0]}set r(t){this[0]=t}get g(){return this[1]}set g(t){this[1]=t}get b(){return this[2]}set b(t){this[2]=t}get h(){return this._mode=="lch"?this[2]:this[0]}set h(t){const e=this._mode=="lch"?2:0;this[e]=t}get s(){return this[1]}set s(t){this[1]=t}get l(){return this._mode=="hsl"?this[2]:this[0]}set l(t){const e=this._mode=="hsl"?2:0;this[e]=t}get a(){return this[1]}set a(t){this[1]=t}get c(){return this[1]}set c(t){this[1]=t}get u(){return this[1]}set u(t){this[1]=t}get v(){return this[2]}set v(t){this[2]=t}set alpha(t){this.length>3&&(this[3]=t)}get alpha(){return this.length>3?this[3]:1}get normalized(){return this._isNorm}set normalized(t){this._isNorm=t}normalize(t=!0){if(this._isNorm==t)return this;const e=m.ranges[this._mode];for(let r=0;r<3;r++)this[r]=t?B.mapToRange(this[r],e[r][0],e[r][1],0,1):B.mapToRange(this[r],0,1,e[r][0],e[r][1]);return this._isNorm=t,this}$normalize(t=!0){return this.clone().normalize(t)}toString(t="mode"){if(t=="hex"){const e=r=>{const n=Math.floor(r).toString(16);return n.length<2?"0"+n:n};return`#${e(this[0])}${e(this[1])}${e(this[2])}`}else return t=="rgba"?`rgba(${Math.floor(this[0])},${Math.floor(this[1])},${Math.floor(this[2])},${this.alpha})`:t=="rgb"?`rgb(${Math.floor(this[0])},${Math.floor(this[1])},${Math.floor(this[2])})`:`${this._mode}(${this[0]},${this[1]},${this[2]},${this.alpha})`}static RGBtoHSL(t,e=!1,r=!1){const[n,i,s]=e?t:t.$normalize(),l=Math.max(n,i,s),a=Math.min(n,i,s);let o=(l+a)/2,f=o;const d=o;if(l==a)o=0,f=0;else{const p=l-a;f=d>.5?p/(2-l-a):p/(l+a),o=0,l===n?o=(i-s)/p+(i<s?6:0):l===i?o=(s-n)/p+2:l===s&&(o=(n-i)/p+4)}return m.hsl(r?o/60:o*60,f,d,t.alpha)}static HSLtoRGB(t,e=!1,r=!1){let[n,i,s]=t;if(e||(n=n/360),i==0)return m.rgb(s*255,s*255,s*255,t.alpha);const l=s<=.5?s*(1+i):s+i-s*i,a=2*s-l,o=d=>(d=d<0?d+1:d>1?d-1:d,d*6<1?a+(l-a)*d*6:d*2<1?l:d*3<2?a+(l-a)*(2/3-d)*6:a),f=r?1:255;return m.rgb(f*o(n+1/3),f*o(n),f*o(n-1/3),t.alpha)}static RGBtoHSB(t,e=!1,r=!1){const[n,i,s]=e?t:t.$normalize(),l=Math.max(n,i,s),a=Math.min(n,i,s),o=l-a;let f=0;const d=l===0?0:o/l,p=l;return l!=a&&(l===n?f=(i-s)/o+(i<s?6:0):l===i?f=(s-n)/o+2:l===s&&(f=(n-i)/o+4)),m.hsb(r?f/60:f*60,d,p,t.alpha)}static HSBtoRGB(t,e=!1,r=!1){let[n,i,s]=t;e||(n=n/360);const l=Math.floor(n*6),a=n*6-l,o=s*(1-i),f=s*(1-a*i),d=s*(1-(1-a)*i),g=[[s,d,o],[f,s,o],[o,s,d],[o,f,s],[d,o,s],[s,o,f]][l%6],v=r?1:255;return m.rgb(v*g[0],v*g[1],v*g[2],t.alpha)}static RGBtoLAB(t,e=!1,r=!1){const n=e?t.$normalize(!1):t;return m.XYZtoLAB(m.RGBtoXYZ(n),!1,r)}static LABtoRGB(t,e=!1,r=!1){const n=e?t.$normalize(!1):t;return m.XYZtoRGB(m.LABtoXYZ(n),!1,r)}static RGBtoLCH(t,e=!1,r=!1){const n=e?t.$normalize(!1):t;return m.LABtoLCH(m.RGBtoLAB(n),!1,r)}static LCHtoRGB(t,e=!1,r=!1){const n=e?t.$normalize(!1):t;return m.LABtoRGB(m.LCHtoLAB(n),!1,r)}static RGBtoLUV(t,e=!1,r=!1){const n=e?t.$normalize(!1):t;return m.XYZtoLUV(m.RGBtoXYZ(n),!1,r)}static LUVtoRGB(t,e=!1,r=!1){const n=e?t.$normalize(!1):t;return m.XYZtoRGB(m.LUVtoXYZ(n),!1,r)}static RGBtoXYZ(t,e=!1,r=!1){const n=e?t.clone():t.$normalize();for(let s=0;s<3;s++)n[s]=n[s]>.04045?Math.pow((n[s]+.055)/1.055,2.4):n[s]/12.92,r||(n[s]=n[s]*100);const i=m.xyz(n[0]*.4124564+n[1]*.3575761+n[2]*.1804375,n[0]*.2126729+n[1]*.7151522+n[2]*.072175,n[0]*.0193339+n[1]*.119192+n[2]*.9503041,t.alpha);return r?i.normalize():i}static XYZtoRGB(t,e=!1,r=!1){const[n,i,s]=e?t:t.$normalize(),l=[n*3.2406254773200533+i*-1.5372079722103187+s*-.4986285986982479,n*-.9689307147293197+i*1.8757560608852415+s*.041517523842953964,n*.055710120445510616+i*-.2040210505984867+s*1.0569959422543882];for(let o=0;o<3;o++)l[o]=l[o]>.0031308?1.055*Math.pow(l[o],1/2.4)-.055:12.92*l[o],l[o]=Math.max(0,Math.min(1,l[o])),r||(l[o]=Math.round(l[o]*255));const a=m.rgb(l[0],l[1],l[2],t.alpha);return r?a.normalize():a}static XYZtoLAB(t,e=!1,r=!1){const n=e?t.$normalize(!1):t.clone(),i=.00885645167,s=903.296296296;n.divide(m.D65);const l=f=>f>i?Math.pow(f,1/3):(s*f+16)/116,a=l(n[1]),o=m.lab(116*a-16,500*(l(n[0])-a),200*(a-l(n[2])),t.alpha);return r?o.normalize():o}static LABtoXYZ(t,e=!1,r=!1){const n=e?t.$normalize(!1):t,i=(n[0]+16)/116,s=n[1]/500+i,l=i-n[2]/200,a=.00885645167,o=903.296296296,f=m.D65,d=Math.pow(s,3),p=Math.pow(l,3),g=m.xyz(f[0]*(d>a?d:(116*s-16)/o),f[1]*(n[0]>o*a?Math.pow((n[0]+16)/116,3):n[0]/o),f[2]*(p>a?p:(116*l-16)/o),t.alpha);return r?g.normalize():g}static XYZtoLUV(t,e=!1,r=!1){let[n,i,s]=e?t.$normalize(!1):t;const l=4*n/(n+15*i+3*s),a=9*i/(n+15*i+3*s);i=i/100,i=i>.008856?Math.pow(i,1/3):7.787*i+16/116;const o=4*m.D65[0]/(m.D65[0]+15*m.D65[1]+3*m.D65[2]),f=9*m.D65[1]/(m.D65[0]+15*m.D65[1]+3*m.D65[2]),d=116*i-16;return m.luv(d,13*d*(l-o),13*d*(a-f),t.alpha)}static LUVtoXYZ(t,e=!1,r=!1){let[n,i,s]=e?t.$normalize(!1):t,l=(n+16)/116;const a=l*l*l;l=a>.008856?a:(l-16/116)/7.787;const o=4*m.D65[0]/(m.D65[0]+15*m.D65[1]+3*m.D65[2]),f=9*m.D65[1]/(m.D65[0]+15*m.D65[1]+3*m.D65[2]);i=i/(13*n)+o,s=s/(13*n)+f,l=l*100;const d=-1*(9*l*i)/((i-4)*s-i*s),p=(9*l-15*s*l-s*d)/(3*s);return m.xyz(d,l,p,t.alpha)}static LABtoLCH(t,e=!1,r=!1){const n=e?t.$normalize(!1):t,i=w.toDegree(w.boundRadian(Math.atan2(n[2],n[1])));return m.lch(n[0],Math.sqrt(n[1]*n[1]+n[2]*n[2]),i,t.alpha)}static LCHtoLAB(t,e=!1,r=!1){const n=e?t.$normalize(!1):t,i=w.toRadian(n[2]);return m.lab(n[0],Math.cos(i)*n[1],Math.sin(i)*n[1],t.alpha)}};J.D65=new u(95.047,100,108.883,1);J.ranges={rgb:new h(new u(0,255),new u(0,255),new u(0,255)),hsl:new h(new u(0,360),new u(0,1),new u(0,1)),hsb:new h(new u(0,360),new u(0,1),new u(0,1)),lab:new h(new u(0,100),new u(-128,127),new u(-128,127)),lch:new h(new u(0,100),new u(0,100),new u(0,360)),luv:new h(new u(0,100),new u(-134,220),new u(-140,122)),xyz:new h(new u(0,100),new u(0,100),new u(0,100))};/*! Pts.js is licensed under Apache License 2.0. Copyright © 2017-current William Ngan and contributors. (https://github.com/williamngan/pts) */const it=(A,t,e=[])=>{K.useEffect(()=>(window.addEventListener(A,t),()=>window.removeEventListener(A,t)),e)};export{u as P,it as u};
